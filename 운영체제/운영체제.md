## 운영체제

---

### 운영체제 역할1: 시스템 자원(system resource) 관리자

- Operating System 또는 OS 라고 부른다.
- 시스템 자원(System Resource) = 컴퓨터 하드웨어
  - CPU (중앙처리장치), 메모리(DRAM, RAM)
  - I/O Devices(입출력장치)
    - Monitor, Mouse, ...
  - 저장매체 : SSD, HDD (하드디스크)

---

### 운영체제 역할

> 컴퓨터 하드웨어는 스스로 할 수 있는 것이 없다.

1. CPU : 각 프로그램이 얼마나 CPU를 사용할지를 결정할 수는 없다.
2. Memory : 각 프로그램이 어느 주소에 저장되어야 하는지, 어느 정도의 메모리 공간을 확보해줘야 하는지를 결정할 수는 없다.
3. 저장매체(HDD, SSD) : 어떻게, 어디에 저장할지는 결정할 수 없다.
4. 키보드/마우스 : 스스로 표시할 수는 없다.

---

### How did we ever run Computer without OS ?

---

### 대표적인 운영체제

- Windows OS, Mac OS, UNIX(유닉스)
- UNIX OS
  - UNIX 계열 OS - LINUX
    - UNIX와 사용법이나, OS 구조가 유사
  - LINUX OS

---

### 컴퓨터 하드웨어와 프로그램을 제어

---

### 운영체제와 응용프로그램

- 응용 프로그램이란 ?
  - 프로그램 = 소프트웨어
  - 소프트웨어 = 운영체제, 응용프로그램(엑셀, 파워포인트 ..)
  - 응용 프로그램 = Application = App

---

### 운영체제와 응용 프로그램간의 관계

- 운영체제는 응용프로그램을 관리

  - 응용 프로그램을 실행시킨다.
  - 응용 프로그램간의 권한을 관리해준다.
    - 관리자 권한으로 실행
  - 응용 프로그램을 사용하는 사용자도 관리
    - 로그인 기능

- 응용 프로그램은 누구나 만들 수 있다.
  - ex) 응용 프로그램에 무한 반복문을 넣었다.
  - 응용 프로그램을 잘 못 작성해서, 프로그램이 다운
  - 모든 파일 삭제 막기(권한 / 사용자 관리)
  - 응용 프로그램이 CPU를 자기만 쓰겠다라고 한다면 운영체제가 관리할 수 있다.

1. 응용 프로그램을 관리한다.
2. 시스템 자원을 관리한다.
3. 사용자와 컴퓨터간의 커뮤니케이션을 지원
   > 운영체제의 목표 : 사용자가 사용하는 응용 프로그램이 효율적으로, 적절하게 동작하도록 지원
   > 운영체제는 응용 프로그램이 요청하는 시스템 리소스를 효율적으로 분배하고, 지원하는 소프트웨어

> 컴퓨터를 키면 ? --> 운영체제는 Memory에 올라가게 된다.
> 참고 : 폰노이만 구조
> -> 폰노이만 구조는 중앙처리장치, 메모리, 프로그램 세 가지 요소로 구성되어 있다. 기억장치의 속도가 전체 시스템의 성능 저하를 야기하는 현상을 폰 노이만 병목현상이라고 한다. 병목현상이 일어나는 근본적 원인은 프로그램 메모리와 데이터 메모리가 물리적 구분 없이 하나의 버스를 통해 CPU와 교류하기 때문이다. 이에 반해, 하버드 구조는 CPU가 명령어와 데이터를 동시에 사용할 수 있도록 명령용 버스와 데이터용 버스를 물리적으로 구분했다. 이를 통해 현재 명령의 처리를 끝냄과 동시에 다음 명령을 읽어 들일 수 있기 때문에 기존의 폰 노이만 구조보다 더 빠른 속도를 낼 수 있다.

### 정리

1. 운영체제의 역할 : 시스템 자원, 응용 프로그램 관리, 효율적 분배
2. 응용 프로그램이란 ? 소프트웨어

---

### 운영체제 구조

- 운영체제는 사용자 인터페이스 제공
  - 쉘(Shell)
    - 사용자가 운영체제 기능과 서비스를 조작할 수 있도록 인터페이스를 제공하는 프로그램
    - 쉘은 터미널 환경(CLI)과, GUI환경 두 종류로 분류

### 운영체제는 응용 프로그램을 위해서도 인터페이스를 제공

- API(Application Programming Interface)

  - 함수로 제공

- 보통은 라이브러리 형태로 제공
  - C library(보통은 C언어로 제공)

### 시스템 콜

- 시스템 콜 또는 시스템 호출 인터페이스
- 운영체제가 운영체제 각 기능을 사용할 수 있도록 시스템 콜이라는 명령 또는 함수를 제공
- API 내부에는 시스템콜을 호출하는 형태로 만들어지는 경우가 대부분

### 운영체제를 만든다면 ?

1. 운영체제를 개발한다. (kernel)
2. 시스템 콜을 개발
3. API library 개발
4. Shell 프로그램 개발
5. 응용 프로그램 개발

---

### 운영체제와 시스템콜

- 시스템콜 정의 예
  - POSIX API, 윈도우 API
    > 시스템콜 : 운영체제 기능을 호출하는 함수

### 정리

- 운영체제는 컴퓨터 하드웨어와 응용 프로그램을 관리한다.
- 사용자 인터페이스를 제공하기 위해 쉘 프로그램을 제공한다.
- 응용 프로그램이 운영체제 기능을 요청하기 위해서, 운영체제는 시스템 콜을 제공한다.
  - 보통 시스템 콜을 직접 사용하기 보다는, 해당 시스템 콜을 사용해서 만든 각 언어별 라이브러리를 사용한다.

---

### 운영체제 구조

1. CPU Protection Rings

- CPU도 권한 모드라는 것을 가지고 있다. - 대표적인 권한 모드 : 사용자 모드 / 커널 모드(특권 명령어로 실행과 원하는 작업 수행을 위한 자원 접근을 가능케 하는 모드 : OS가 CPU를 사용할 때)
  > Kernel 이란 ?
  > OS 본연의 기능 / 핵심 소프트웨어

> shell 이란 ?
> Kernel의 껍데기(운영체제를 감싸고 있는 것)

### 시스템콜은 커널 모드로 실행

- 커널 모드에서만 실행 가능한 기능들이 있다.
- 커널 모드로 실행하려면, 반드시 시스템 콜을 사용해야 한다.
- 시스템 콜은 운영체제 제공

### 정리

- 운영체제는 시스템 콜 제공
- 프로그래밍 언어별로 운영체제 기능을 활용하기 위해, 시스템 콜을 기반으로 API 제공
- 응용 프로그램은 운영체제 기능 필요시, 해당 API를 사용해서 프로그램을 작성
- 응용 프로그램이 실행되서, 운영체제 기능이 필요한 API를 호출하면, 시스템 콜이 호출되서, 커널모드로 변경되어 OS내부에서 해당 명령이 실행되고, 다시 응용 프로그램이 돌아간다.

---

### 프로세스 스케줄링

- 배치 처리 시스템, 시분할 시스템, 멀티 태스킹

### 배치 처리 시스템

- 여러 프로그램을 순차적으로 실행시킬 수 있다.
  - 어떤 프로그램은 실행이 너무 시간이 많이 걸려서, 다른 프로그램이 실행하는데 시간을 많이 기다려야 한다. -> 시분할 시스템 / 멀티 프로그래밍이 나타났다.

### 시분할 시스템

: 다중 사용자 지원을 위해 컴퓨터 응답시간을 최소화하는 시스템

### 멀티 태스킹

: 단일 CPU에서, 여러 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 시스템

### 멀티 태스킹과 멀티 프로세싱

- 멀티 태스킹 : 단일 CPU
- 멀티 프로세싱 : 여러 CPU에 하나의 프로그램을 병렬로 실행해서 실행속도를 극대화시키는 시스템

### 프로세스 스케쥴링 - 멀티 프로그래밍

- 최대한 CPU를 많이 활용하도록 하는 시스템
  - 시간 대비 CPU 활용도를 높이자
  - 응용 프로그램을 짧은 시간 안에 실행 완료를 시킬 수 있다

### 멀티 프로그래밍

- 응용 프로그램은 온전히 CPU를 쓰기보다, 다른 작업을 중간에 필요로 하는 경우가 많다.
  - 응용 프로그램이 실행되다가 파일을 읽는다. -> ex) 저장매체에서 파일을 읽을때 -> CPU는 아무일도 하지 못한다.
  - 응용 프로그램이 실행되다가 프린팅을 한다.

### 메모리 계층 / 시스템 버스 - 컴퓨터 구조

### 정리

- 시분할 시스템 : 다중 사용자 지원, 컴퓨터 응답시간을 최소화하는 시스템
- 멀티 태스킹 : 단일 CPU에서 여러 응용 프로그램을 동시에 실행하는 것처럼 보이게 하는 시스템
- 멀티 프로세싱 : 여러 CPU에서 하나의 응용 프로그램을 병렬로 실행하게 해서, 실행속도를 높이는 기법
- 멀티 프로그래밍 : 최대한 CPU를 일정 시간당 많이 활용하는 시스템

### 프로세스란 ?

- 실행 중인 프로그램은 프로세스라고 한다.
  - 프로세스 : 메모리에 올려져서, 실행 중인 프로그램
  - 코드 이미지(바이너리) : 실행 파일

> 프로세스라는 용어는 작업, task, job이라는 용어와 혼용

- 프로세스 실행을 관리 ? -> 스케줄러

### 스케줄링 알고리즘

> 어느 순서대로 프로세스를 실행시킬까 ?

- 목표
  - 시분할 시스템 : 프로세스 응답 시간을 가능한 짧게
  - 멀티 프로그래밍 : CPU 활용도를 최대로 높혀서, 프로세스를 빨리 실행

### FIFO 스케줄러

> 프로세스가 저장매체를 읽는 다든지, 프린팅을 한다든지 하는 작업 없이, 쭉 CPU를 처음부터 끝까지 사용한다.

- FCFS(First Come First Served) 스케줄러

### 최단 작업 우선(SJF) 스케줄러

- SJF(Shorted Job First) : 가장 프로세스 실행시간이 짧은 프로세스부터 먼저 실행시키는 알고리즘

###

- RealTime OS(RTOS) : 응용 프로그램 실시간 성능 보장을 목표로 하는 OS
  - 정확하게 프로그램 시작, 완료 시간을 보장 -> 시간에 민감한 프로그램을 돌릴 경우
- General Purpose OS(GPOS)
  - 프로세스 실행시간에 민감하지 않고, 일반적인 목적으로 사용되는 OS ex) windows, Linux 등

### 우선 순위 기반 스케줄러

- Priority-Based 스케줄러
  - 정적 우선순위
    - 프로세스마다 우선순위를 미리 지정
  - 동적 우선순위
    - 스케줄러가 상황에 따라 우선순위를 동적으로 변경

### Round Robin 스케줄러

- 시분할 시스템 기반으로 한 스케줄러 -> 각 순서대로 다시 큐에 쌓여 실행되는 스케줄러

### 멀티 프로그래밍과 Wait

- 멀티 프로그래밍 : CPU활용도를 극대화 하는 스케줄링 알고리즘
- Wait : 간단히 저장매체로부터 파일 읽기를 기다리는 시간으로 가정

### 프로세스 상태

- new : 프로세스 생성
- ready : 실행 가능
- running : 실행 중
- blocked : 대기
- exit : 대기
  - runngion state : 현재 CPU에서 실행 상태
  - ready state : CPU에서 실행 가능 상태 (실행 대기 상태)
  - block state : 특정 이벤트 발생 대기 상태(저장매체에서 파일을 읽는 중일 경우 대기상태)

> 프로세스 상태간 관계는 running상태 / block상태 / ready상태 순환을 하면서 실행된다

### 선점형 / 비선점형 스케줄러

- 선점형 스케줄러(Preemtive Scheduling)
  : 하나의 프로세스가 다른 프로세스 대신에 프로세서(CPU)를 차지할 수 있다.
- 비선점형 스케줄러(Non-preemtive Scheduling)
  : 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없다.

### 선점형과 비선점형 스케줄러 차이

- 비선점형 : 프로세스가 자발적으로 blocking 상태로 들어가거나, 실행이 끝났을 때만, 다른 프로세스로 교체가능
- 선점형 : 프로세스 running 중에 스케줄러가 이를 중단시키고, 다른 프로세스로 교체 가능 -> 응답시간이 짧아질 수 있다

### 스케줄러 구분

- FIFO, SJF, Priority-based는 어떤 프로세스를 먼저 실행시킬지에 대한 알고리즘
- RoundRobin은 시분할 시스템을 위한 기본 알고리즘(선점형 스케줄러)

### 인터럽트

: CPU가 프로그램을 실행하고 있을때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우에 CPU에 알려서 처리하는 기술

> 어느 한순간 CPU가 실행하는 명령은 하나! 다른장치와 어떻게 커뮤니케이션을 할 수 있을까 ?

### 인터럽트 필요 이유

- 선점형 스케줄러 구현

  - 프로세스 running 중에 스케줄러가 이를 중단시키고, 다른 프로세스로 교체하기 위해, 현재 프로세스 실행을 중단시킴

    - 그러려면, 스케줄러 코드가 실행이 되서, 현 프로세스 실행을 중지시켜야 한다.

  - IO Device와의 커뮤니케이션

    - 저장매체에서 데이터 처리 완료시, 프로세스를 깨워야 한다. (block state -> ready state)

  - 예외 상황 핸들링
    - CPU가 프로그램을 실행하고 있을때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생할 경우, CPU가 해당 처리를 할 수 있도록 CPU에 알려줘야 한다.

### 인터럽트 처리 예

- CPU가 프로그램을 실행하고 있을때,
  - 입출력 하드웨어 등의 장치 이슈 발생
    - 파일 처리가 끝났다는 것을 운영체제에 알려주기
    - 운영체제는 해당 프로세스를 block state에서 실행 대기(ready) 상태로 프로세스 상태 변경하기
  - 또는 예외 상황이 발생
    - 0으로 나누는 계산이 발생해서, 예외 발생을 운영체제에 알려주기
    - 운영체제가 해당 프로세스 실행 중지/에러 표시

### 이벤트와 인터럽트

- 인터럽트는 일종의 이벤트로 불린다.
- 이벤트에 맞게 운영체제가 처리

- 타이머 인터럽트

  - 선점형 스케줄러를 위해 필요 : 하드웨어로 부터 일정 시간마다 타이머 인터럽트를 운영체제에 알려준다.

- 입출력 인터럽트
  : 프린터, 키보드, 마우스, 저장매체

- 내부 인터럽트

  - 주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시 발생
    - 0으로 나눴을 떄
    - 사용자 모드에서 허용되지 않은 명령 또는 공간 접근시
    - 게산 결과가 overflow / underflow 날 때

- 외부 인터럽트
  - 주로 하드웨어에서 발생되는 이벤트(프로그램 외부)
    - 전원 이상
    - 기계 문제
    - 키보드 등 IO 관련 이벤트
    - Timer 이벤트

### 인터럽트 종류

- 내부 인터럽트는 주로 프로그램 내부에서 발생하므로, 소프트웨어 인터럽트라고 한다.
- 외부 인터럽트는 주로 하드웨어에서 발생하므로, 하드웨어 인터럽트라고 한다.

### 인터럽트 내부 동작

- 시스템 콜 인터럽트
  - 시스템콜 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어, CPU에게 실행시켜야 한다.
  - 시스템 콜 실제 코드
    - eax 레지스터에 시스템 콜 번호를 넣고,
    - ebx 레지스터에는 시스템 콜에 해당하는 인자값을 넣고,
    - 소프트웨어 인터럽트 명령을 호출하면서 0x80값을 넘겨준다

### 인터럽트와 시스템 콜

- 시스템콜 인터럽트 명령을 호출하면 0x80값을 넘겨준다.
  1. CPU는 사용자모드를 커널모드로 바꿔준다
  2. IDT(Interrupt Descriptor Table : 인터럽트 번호 -> 주소)에서 0x80에 해당하는 주소(함수)를 찾아서 실행한다.
  3. system_call()함수에서 eax(시스템콜 번호가 존재)로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동
  4. 해당 시스템콜 함수 실행 후, 다시 커널 모드에서 사용자 모드로 변경하고, 다시 해당 프로세스 다음 토드 진행

### 인터럽트와 IDT

- 인터럽트는 미리 정의되어 각각 번호와 실행 코드를 가리키는 주소가 기록되어 있다.

  - IDT에 이벤트번호: 실행코드의 주소(함수)를 기록
  - 컴퓨터 부팅시 운영체제가 기록
  - 운영체제 내부 코드

  - 항상 인터럽트 발생시, IDT를 확인
  - 시스템콜 인터럽트 명령은 0x80 번호가 미리 정의
  - 인터럽트 0x80에 해당하는 운영체제 코드는 system_call()
  - 즉, IDT에는 0x80 -> system_call()와 같은 정보가 기록되어 있다.

  : 인터럽트는 번호가 존재, 번호에 해당하는 함수(코드)들이 존재, 이는 운영체제에 존재한다. 코드와 관련 번호는 IDT에 담겨져있다. 인터럽트가 발생시 IDT를 참조한다.

### 인터럽트와 프로세스

1. 프로세스 실행 중 인터럽트 발생
2. 현 프로세스 실행 중단
3. 인터럽트 처리 함수 실행(운영체제)
4. 현 프로세스 재실행

### 프로세스와 컨텍스트 스위칭

- 프로세스 구조 deep dive

- 프로세스는 일반적으로 어떻게 구성되어 있을까 ?

  - text(CODE) : 코드
  - data : 변수/초기화된 데이터 -> BSS(초기화 않은 전역변수)/DATA(초기값이 있는 전역변수)로 분리 가능
  - stack : 임시 데이터(함수 호출, 로컬 변수 등)
  - heep : 코드에서 동적으로 만들어지는 데이터

- 스택 오버플로우 : 주로 해커들의 공격에 활용되었다.

- PCB : 프로세스 상태정보관리, (PC, SP) -> 컨텍스트 스위칭, 메모리, 스케줄링 정보 등

- Context Switching(문맥 교환)
  - cpu에 실행할 프로세스를 교체하는 기술
  1. 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서, 메인 메모리에 저장
  2. 다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB정보(PC, SP)를 CPU의 레지스터에 넣고, 실행
     > 컨텍스트 스위칭 시간이 오래 걸리면, 실제로는 굉장히 짧은 시간(ms) 단위로, 프로세스 스위칭이 일어난다.

### 컴파일러

- 초기 컴퓨터 프로그램들은 어셈블리어로 작성
  - 서로 다른 cpu아키텍처가 등장할 때마다 매번 똑같은 프로그램 작성(프로그램의 이식성이 떨어진다.)
  - 어셈블리어로는 프로그램 작성 속도가 매우 떨어진다.
- 컴파일러 등장
  - cpu아키텍처에 따라서는 컴파일러 프로그램만 만들면 된다. 기존 코드는 재작성할 필요없다.
  - 그러나, 어셈블리어로 작성한 코드보다는 속도가 떨어질 수 있다.

### IPC(InterProcess Communication)

> 프로세스들이 서로의 공간에 접근할 수 없다.

### 프로세스간 통신이 필요한가?

- 성능을 높이기 위해 여러 프로세스를 만들어서 동시 실행
- 이때 프로세스간 상태 확인 및 데이터 송수신이 필요

- 프로세스간 공간은 완전히 분리되어 있다. / 커널공간은 공유한다

### IPC 기법

- file 사용
- Message Queue
- Shared Memory
- Pipe
- Signal
- Semaphore
- Socket

- 여러 프로세스 동시 실행을 통한 성능개선, 복잡한 프로그램을 위해 프로세스간 통신 필요
- 프로세스간 공간이 완전부닐
- 프로세스간 통신을 위한 특별한 기법 필요
  - IPC
- 대부분의 IPC기법은 결국 커널 공간을 활용하는 것 : 커널 공간은 공유하기 때문

### 파이프 Pipe

- 기본 파이프는 단방향 통신
- fork()로 자식 프로세스 만들었을 때, 부모와 자식간의 통신

### 파이프와 메시지 큐

- message queue는 부모/자식이 아니라, 어느 프로세스간에라도 데이터 송수신이 가능
- 먼저 넣은 데이터가, 먼저 읽혀진다

### pipe vs message queue

- 부모/자식 프로세스간 only or not
- 단방향만 가능 or 양방향 가능

### IPC기법과 커널 모드

- pipe, message queue 는 모두 kernel 공간의 메모리를 사용한다.
- 메모리 공간도 kernel/user로 구분된다.

### 공유 메모리

- 노골적으로 kernel space에 메모리 공간을 만들고, 해당 공간을 변수처럼 쓰는 방식
- message queue처럼 FIFO방식이 아니라, 해당 메모리 주소를 마치 변수처럼 접근하는 방식

### 프로세스간 커뮤니케이션

ex) signal, socket

1. 시그널

- 유닉스에서 30년 이상 사용된 전통적인 기법
- 커널 또는 프로세스에서 다른 프로세스에 어떤 이벤트가 발생되었는지를 알려주는 기법
- 프로세스 관련 코드에 관련 시그널 핸들러를 등록해서, 해당 시그널 처리 실행
  - 시그널 무시
  - 시그널 블록
  - 등록된 시그널 핸들러로 특정 동작 수행
  - 등록된 시그널 핸들러가 없다면, 커널에서 기본 동작 수행

> 커널모드에서 사용자모드로 전환시 시그널 처리

2. 소켓

- 소켓은 네트워크 통신을 위한 기술
- 기본적으로는 클라이언트와 서버등 두 개의 다른 컴퓨터간의 네트워크 기반 통신을 위한 기술
- 소켓을 하나의 컴퓨터 안에서, 두개의 프로세스간에 통신 기법으로 사용 가능

### Thread(스레드)

- Light Weight Process라고도 한다.
- 프로세스
  - 프로세스 간에는 각 프로세스의 데이터 접근이 불가 -> IPC를 이용
- 스레드
  - 하나의 프로세스에 여러개의 스레드 생성 가능
  - 스레드들은 동시에 실행 가능
  - 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능
    > Thread는 각기 실행이 가능한 stack 존재, 프로세스와 달리 스레드간 자원 공유

### Multi Thread

- 소프트웨어 병행 작업 처리를 위해 멀티 스레드를 사용한다.

### 멀티 프로세승과 Thread

- 멀티태스킹과 멀티 프로세싱
- 최근 CPU는 멀티 코어를 가지므로, Thread를 여러 개 만들어, 멀티 코어를 활용도를 높인다.

### Thread 장점

1. 사용자에 대한 응답성 향상
2. 자원 공유 효율

- IPC 기법과 같이 프로세스간 자원 공유를 위해 번거로운 작업이 필요 없음
- 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능

3. 작업이 분리되어 코드가 간결

- 작성하기 나름

### Thread 단점

- 스레드 중 한 스레드만 문제가 있어도, 전체 프로세스가 영향을 받는다.
- 멀티 프로세스
- 멀티 스레드
- 스레드를 많이 생성하면, Context Switching이 많이 일어나, 성능 저하
- ex) 리눅스 OS에서는 Thread를 Process와 같이 다룬다.
  - 스레드를 많이 생성하면, 모든 스레드를 스케줄링해야 하므로, Context Switching이 빈번할 수 밖에 없다.

### Thread vs Process

- 프로세스는 독립적, 스레드는 프로세스의 서브셋
- 프로세스는 각각 독립적인 자원을 가진다. 스레드는 프로세스 자원 공유
- 프로세스는 자신만의 주소영역을 가진다. 스레드는 주소영역 공유
- 프로세스간에는 IPC기법으로 통신해야 한다. 스레드는 필요 없다.

### PThread

- POSIX 스레드 : Thread관련 API

### 동기화 이슈

- 동기화 : 작업들 사이에 실행 시기를 맞추는 것
- 여러 스레드가 동일한 자원 접근시 동기화 이슈 발생
  - 동일 자원을 여러 스레드가 동시 수정시, 각 스레드 결과에 영향을 준다.

### 해결 방안

- Mutual exclusion (상호 배제) : 임계자원 / 임계영역
- 스레드는 프로세스 모든 데이터를 접근할 수 있으므로,
  - 여러 스레드가 변경하는 공유 변수에 대해 Exclusive Access 필요
  - 어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근하지 못하도록 막는다.

### Mutex와 세마포어(Semaphore)

- Critical Section(임계 구역)에 대한 접근을 막기 위해 LOCKING 매커니즘이 필요
  - Mutext(binary semaphore) : 임계구역에 하나의 스레드만 들어갈 수 있다.
  - Semaphore : 임계구역에 여러 스레드가 들어갈 수 있다. counter를 두어서 동시에 리소스에 접근 할 수 있는 허용 가능한 스레드 수를 제어

### 교착상태(Deadlock)와 기아상태(Starvation)

1. 교착상태(Deadlock) ?

- 무한 대기 상태 : 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에, 다음 단계로 진행하지 못하는 상태

  > 배치 처리 시스템에서는 일어나지 않는 문제, 프로세스, 스레드 둘다 이와 같은 상태가 일어날 수 있다.

- 다음 네 가지 조건이 모두 성립될 때, 교착상태 발생 가능성이 있다.

1. 상호배제(Mutual exclusion) : 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
2. 점유대기(Hold and wait) : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
3. 비선점(No preemption) : 프로세스가 어떤 자원의 사용을 끝낼 떄까지 그 자원을 뺏을 수 없다.
4. 순환대기(Circular wait) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.

- 교착상태 예방

1. 상호배제 조건의 제거 : 임계 영역 제거
2. 점유와 대기 조건의 제거 : 한번에 모든 필요 자원 점유 및 해제
3. 비선점 조건 제거 : 선점 가능 기법을 만들어준다.
4. 순환 대기 조건 제거 : 자원 유형에 따라 순서를 매긴다.

- 교착상태 발견과 회복
  - 교착상태 발견 : 교착상태가 발생했는지 점검하여 교착 상태에 있는 프로세스와 자원을 발견하는 것
  - 교착상태 회복 : 교착 상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것

2. 기아상태(Starvation)

- 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태
- 교착상태와 기아상태

  - 교착상태는 여러 프로세스가 동일 자원 점유를 요청할 때 발생
  - 기아상태는 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 영원히 자원할당이 안되는 경우를 주로 의미한다.

  - 기아상태 해결 방안
    - 우선순위 변경
      1. 프로세스 우선순위를 수시로 변경해서, 각 프로세스가 높은 우선순위를 가질 기회주기
      2. 오래 기다린 프로세스의 우선순위를 높여주기
      3. 우선순위가 아닌, 요청 순서대로 처리하는 FIFO 기반 요청큐 사용

### 가상메모리

> 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있다.

> 폰노이만 구조 기반이므로, 코드는 메모리에 반드시 있어야 한다
> 적은메모리에서 어떻게 프로세스를 가져가야 할까 ?

### 가상메모리가 필요한 이유

- 하나의 프로세스만 실행 가능한 시스템(배치 처리 시스템등)

1. 프로그램을 메모리로 로드
2. 프로세스 실행
3. 프로세스 종료(메모리 해제)

- 여러 프로세스 동시 실행 시스템

1. 메모리 용량 부족 이슈
2. 프로세스 메모리 영역간에 침범 이슈

### 가상 메모리

- 가상 메모리 : 메모리가 실제 메모리보다 많아 보이게 하는 기술
  - 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
  - 프로세스간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있다.

1. 가상 메모리 기본 아이디어

- 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고 쓸때만 물리 주소로 바꿔주면 된다.
- virtual address(가상 주소) : 프로세스가 참조하는 주소
- physical address(물리 주소) : 실제 메모리 주소

2. MMU(Memory Management Unit)

- CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치

3. 메인 메모리에 실제 각 프로세스의 데이터가 조각으로 씌여 있다.
4. CPU는 가상 메모리를 다루고, 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근

- 하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 별도 장치를 둔다.

### 페이징 시스템

- 페이징 개념
  - 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
  - 하드웨어 지원이 필요
  - 리눅스에서는 4KB로 paging
  - 페이지 번호를 기반으로 가상 주소 / 물리 주소 매핑 정보를 기록 / 사용

### 페이징 시스템

> 실질적인 예를 기반으로 페이징 시스템

- 프로세스(4GB)의 PCB에 Page Table 구조체를 가리키는 주소가 들어있다.
- Page Table에는 가상 주소와 물리 주소간 매핑정보가 있다

### 페이징 시스템 구조

- page 또는 page frame : 고정된 크기의 block(4KB)
- paging system
  - 가상 주소 v = (pad)
    - p : 가상 메모리 페이지
    - d : p안에서 참조하는 위치
- 페이지 크기가 4KB 예
  - 가상 주소의 0비트에서 11비트가 변위(d)를 나타내고, 12비트 이상이 페이지 번호가 될 수 있다.

### 다중 단계 페이징 시스템

- 페이징 정보를 단계를 나누어 생성
  - 필요없는 페이지는 생성하지 않으면, 공간 절약 가능
- 페이지 번호를 나타내는 bit를 구분해서, 단계를 나눈다(리눅스는 3단계, 최근 4단계)

### MMU와 TLB(컴퓨터 구조)

- MMU가 물리 주소를 확인하기 위해 메모리를 갔다와야 한다.

### 페이징 시스템과 공유 메모리

- 프로세스간 동일한 물리 주소를 가리킬 수 있다(공간 절약, 메모리 할당 시간 절약)

### 요구 페이징 (Demand Paging or Demanded Paging)

- 프로세스 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재함
  - 선행 페이징의 반대 개념 : 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행하는 개념
  - 더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장(페이지 교체 알고리즘 필요)

### 페이지 폴트

- 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트
- 운영체제가 page fault가 일어나면, 해당 페이지를 물리 메모리에 올림

### 페이지 교체 정책

- 운영체제가 특정 페이지를 물리 메모리에 올리려 하는데, 물리 메모리가 다 차있다면 ? - 기존 페이지 중 하나를 물리 메모리에서 저장매체로 내리고 (저장) - 새로운 페이지를 해당 물리 메모리 공간에 올린다.
  > 어떤 페이지를 물리 메모리에서, 저장 매체로 내릴 것인가 ? -> Page Replacement(Swapping) 알고리즘

### 세그멘테이션

- 가상메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할
  - 페이징 기법에서는 가상 메모리를 같은 크기의 블록으로 분할
  1.  내부 단편화 : 페이지 블록만큼 데이터가 딱 맞게 채워져있지 않을 때 공간 낭비
  2.  외부 단편화(세그멘테이션 기법) : 물리 메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우
  3.  세그멘테이션 / 페이징 모두 하드웨어 지원 필요 : 다양한 컴퓨터 시스템에 이식성을 중요시하는 리눅스는 페이징 기법을 기반으로 구현

### 파일 시스템

: 운영체제가 저장매체에 파일을 쓰기 위한 자료구조 또는 알고리즘

1. 파일시스템이 만들어진 이유(블록)

- 0과 1의 데이터를 어떻게 저장매체에 저장할까?
  - 비트로 관리하기는 오버헤드가 너무 크다
  - 블록 단위로 관리하기(보통 4KB)
  - 블록마다 고유번호를 부여해서, 관리

2. 파일시스템이 만들어진 이유(파일)

- 사용자가 각 블록 고유 번호를 관리하기 어렵다.
  - 추상적(논리적) 객체 필요 : 파일
- 사용자는 파일단위로 관리
  - 각 파일에는 블록 단위로 관리

3. 파일 시스템이 만들어진 이유(저장 방법)

- 저장매체에 효율적으로 파일을 저장하는 방법
  - 가능한 연속적인 공간에 파일을 저장하는 것이 좋다
  - 외부 단편화, 파일 사이즈 변경 문제로 불연속 공간에 파일 저장 기능 지원 필요
    - 블록 체인 : 블록을 링크드 리스트로 연결
      - 끝에 있는 블록을 찾으려면, 맨 처음 블록부터 주소를 따라가야 한다
    - 인덱스 블록 기법 : 각 블록에 대한 위치 정보를 기록해서, 한번에 끝 블록을 찾아갈 수 있도록 한다.

4. 다양한 파일 시스템

- Windows : FAT, FAT32, NTFS
  - 블록 위치를 FAT라는 자료 구조에 기록
- 리눅스 : ext2, ext3, ext4
  - 일종의 인덱스 블록 기법인 inode 방식 사용

### inode 방식 파일 시스템

- 파일 시스템 기본 구조
  - 수퍼 블록 : 파일 시스템 정보 및 파티션 정보 포함
  - 아이노드 블록 : 파일 상세 정보
  - 데이터 블록 : 실제 데이터

### inode와 파일

- 파일 : inode 고유값과 자료구조에 의해 주요 정보 관리
  - ‘파일이름:inode’로 파일이름은 inode 번호와 매칭
  - 파일 시스템에서는 inode를 기반으로 파일 엑세스
  - inode 기반 메타 데이터 저장

### inode 구조

- inode 기반 메타 데이터(파일 권한, 소유자 정보, 파일 사이즈, 생성시간 등 시간 관련 정보, 데이터 저장 위치 등)

### 가상 파일 시스템(Virtual File System)

- Network 등 다양한 기기도 동일한 파일 시스템 인터페이스를 통해 관리 가능
- ex) read/write 시스템콜 사용, 각 기기별 read_spec/write_spec 코드 구현 (운영체제 내부)

### Boot

- Boot 프로그램 : 운영체제 커널을 Storage에서 특정 주소의 물리 메모리로 복사하고 커널의 처음 실행위치로 PC를 가져다 놓는 프로그램
- 컴퓨터를 키면 BIOS가 특정 Storage 읽어와서 bootstrap loader를 메모리에 올리고 실행한다. Bootstrap leader 프로그램이 있는 곳을 찾아서 실행 시킨다.

### Virtual Machine(가상머신)

- 하나의 하드웨어에 다수의 운영체제를 설치하고, 개별 컴퓨터처럼 동작하도록 하는 프로그램

### Virtual Machine Type1

- 하이퍼 바이저 : 운영체제와 응용프로그램을 물리적 하드웨어에서 분리하는 프로세스
- 하이퍼 바이저 또는 버추얼 머신 모니터(VMM)라고 하는 소프트웨어가 Hardware에서 직접 구동

### Virtual Machine Type2

- 하이퍼 바이저 또는 버추얼 머신 모니터라고 하는 소프트웨어가 Host OS 상위에 설치
  - VMWare, Parallels Desktop

### Full Virtualization vs Half Virtualization

- 전가상화 : 각 가상머신이 하이퍼바이저를 통해서 하드웨어와 통신
  - 하이퍼 바이저가 마치 하드웨어인 것처럼 동작하므로, 가상머신의 OS는 자신이 가상 머신인 상태인지를 모른다.
- 반가상화 : 각 가상머신에서 직접 하드웨어와 통신
  - 각 가상머신에 설치되는 OS는 가상 머신인 경우, 이를 인지하고, 각 명령에 하이퍼바이저 명령을 추가해서 하드웨어와 통신

### Docker

- 가상 머신은 컴퓨터 하드웨어를 가상화(하드웨어 전체 추상화)
  - 하이퍼바이저 사용, 추가 OS 필요 등 성능 저하 이슈 존재
- Docker는 운영체제 레벨에서 별도로 분리된 실행환경을 제공(커널 추상화)
  - 마치 리눅스 처음 설치했을때와 유사한 실행환경을 만들어주는 리눅스 컨테이너 기술 기반
  - 리눅스 컨테이너 기술이므로 macOS나 windows에 설치할 경우는 가상 머신 기반 제공

### 가상 머신 정리

- Bare-Metal 방식이 가장 성능이 좋다
  - 하드웨어 직접 액세스하기 때문
  - AWS환경도 Bare-Metal 기반 가상 머신 기술 활용(KVM)
- Docker는 경량 이미지로 실행환경을 통째로 백업, 실행가능
  - Data Engineering에서 Docker로 시스템 환경 설정+프로그램을 한번에 배포

### Java Virtual Machine

- 가상 머신과는 다른 목적 (응용프로그램 레벨 가상화)
- Java 컴파일러는 CPU dependency를 가지지 않는 bytecode를 생성한다
- 이 파일을 Java Virtual Machine에서 실행
- 각 운영체제를 위한 Java Virtual Machine 프로그램 존재
