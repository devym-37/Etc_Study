### 리눅스와 파일

-   모든 것은 파일이라는 철학을 따른다

    -   모든 인터렉션은 파일을 읽고, 쓰는 것처럼 이루어져있다
    -   마우스, 키보드와 같은 모든 디바이스 관련된 기술도 파일과 같이 다루어진다

-   파일은 inode 고유값과 자료구조에 의해 주요 정보 관리

### 리눅스와 프로세스

-   리눅스 실행 파일 포멧 - ELE
    -   콜스택, 코드(텍스트), 데이터 및 BSS 섹션 등
-   다양한 시스템 리소스와 관련
    -   시스템콜 호출을 통해 리소스 처리 가능토록 구성
        -   타이머, 시그널, 파일, 네트워크, 디바이스, IPC기법
-   가상 메모리 지원
-   각 프로세스는 pid(프로세스 ID) 고유값으로 구분
-   init 프로세스(첫 번째 프로세스)를 기반으로 fork() 시스템콜을 사용해서, 신규 프로세스가 생성

### 리눅스와 권한

-   운영체제는 사용자/리소스 권한을 관리
-   리눅스는 사용자/그룹으로 권한을 관리
-   root는 슈퍼관리자
-   파일마다 소유자, 소유자 그룹, 모든 사용자에 대해

    -   읽고, 쓰고, 실행하는 권한을 관리
    -   접근 권한 정보는 inode의 자료구조에 저장

-   리눅스는 모든 리소스를 파일로 관리한다. (inode)
-   리눅스의 프로세스
    -   ELF 포맷
    -   시스템콜 기반 리소스 처리 가능토록 구성
        -   타이머, 시그널, 파일, 네트워크 등
    -   가상 메모리 사용
    -   pid 기반 구분
    -   init 프로세스 기반 fork() 사용해서, 프로세스가 생성
-   리눅스 사용자 (로그인 사용자/그룹) 권한 관리
-   리눅스 리소스 (소유자, 소유자 그룹, 모든 사용자에 대한 읽고, 쓰고, 실행하는 권한 설정) 권한 관리

### 리눅스와 파일 정리

-   모든 것은 파일이라는 철학을 따른다
    -   모든 인터렉션은 파일을 읽고, 쓰는 것처럼 이루어져있음
    -   마우스, 키보드와 같은 모든 디바이스 관련된 기술도 파일과 같이 다루어진다
    -   모든 자원에 대한 추상화 인터페이스로 파일 인터페이스를 활용

### 슈퍼블록, inode와 파일

-   슈퍼블록 : 파일 시스템의 정보
-   파일 : inode 고유값과 자료구조에 의해 주요 정보 관리
    -   ‘파일이름 : inode’로 파일이름은 inode 번호와 매칭
    -   파일 시스템에서는 inode를 기반으로 파일 엑세스
    -   inode 기반 메타 데이터 저장

### 하드 링크와 소프트 링크

-   하드 링크 / 소프트 링크 둘다 어느 하나 파일을 수정하면, 각 파일 이름으로 동일한 내용 접근 가능

### 특수 파일

-   디바이스

    -   블록 디바이스 : HDD, CD/DVD와 같이 블록 또는 섹터 등 정해진 단위로 데이터 전송, IO 송수신 속도가 높음
    -   캐릭터 디바이스 : 키보드, 마우스 등 byte 단위 데이터 전송, IO 송수신 속도가 낮음

-   파일 추상화 인터페이스를 활용 다양한 데이터/디바이스 접근
-   파일 네임스페이스는 전역 네임스페이스 활용(/media/floofy/dava.jpg)
-   ‘파일 이름 : inode’로 매칭, 파일 시스템은 inode 기반 접근
-   하드 링크 : 동일 inode 가리키는 파일 이름만 하나 더 만든다
-   소프트 링크 : 특정 파일 바로가기 파일을 만든다
-   ln 명령 알아두기
-   특수 파일 : 블록 / 캐릭터 디바이스

### 시스템 프로그래밍의 기반 요소

-   시스템 콜
-   C 라이브러리
-   C 컴파일러
    > 사용자 영역에서의 시스템 프로그래밍

### 시스템 콜

-   시스템콜 : 운영체제 리소스나 서비스 요청을 위해, 사용자 영역에서 커널 영역으로 들어가는 함수
-   주요 시스템콜 : read(), write(), open() 등
    > 리눅스/유닉스는 C언어로 만들어져있으므로, 시스템콜도 C언어로 구현

### 시스템 콜은 어떻게 구현하나?

-   eat 레지스터에 시스템 콜 번호를 넣고, ebx레지스터에는 시스템 콜에 해당하는 인자값을 넣고, 소프트웨어 인터럽트 명령을 호출하면서 0x80값을 넘겨준다

    -   CPU는 사용자 모드를 커널 모드로 바꿔준다
    -   IDT(Interrupt Descriptor Table)에서 0x80에서 해당하는 주소(함수)를 찾아서 실행한다
    -   system_call() 함수에서 eax로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동
    -   해당 시스템콜 함수 실행 후, 다시 커널 모드에서 사용자 모드로 변경하고, 다시 해당 프로세스 다음 코드 진행

### API

-   응용 프로그램과 분리된 하위 호환 인터페이스

    -   예 : 시스템 콜 래퍼, 입출력 라이브러리 등

-   프로그램 : 바이너리, 코드 이미지, 응용 프로그램, Application, 또는 실행 파일
-   프로세스 : 실행 중인 프로그램 (메모리 적재 + 프로세스 상태 정보 포함)
-   스레드
    -   리눅스 프로세스는 기본 스레드 포함
    -   싱글스레드 프로세스 : 기본 프로세스
    -   멀티스레드 프로세스 : 여러 스레드 존재

### 프로세스 계층

-   최초 프로세스 : init 프로세스, pid 1
-   init 프로세스는 운영체제가 생성
-   다른 프로세스는 또다른 프로세스로부터 생성
    -   부모 프로세스, 자식 프로세스
-   paid 값이 부모 프로세스의 pid를 뜻한다

### 프로세스와 소유자 관리

-   리눅스 내부에서는 프로세스의 소유자와 그룹을 UID/GID (정수)로 관리
-   사용자에 보여줄때에만 UID와 사용자이름 매핑 정보를 기반으로 사용자 이름으로 제공

### fork() 와 exec() 시스템콜

-   fork() 시스템콜
    -   새로운 프로세스 공간을 별도로 만들고, fork() 시스템콜을 호출한 프로세스(부모 프로세스) 공간을 모두 복사
        -   별도의 프로세스 공간을 만들고, 부모 프로세스 공간의 데이터를 그대로 복사
-   exec() 시스템콜
    -   exec() 시스템콜을 호출한 현재 프로세스 공간의 TEXT, DATA, BSS 영역을 새로운 프로세스의 이미지로 덮어씌움
        -   별도의 프로세스 공간을 만들지 않는다

### fork() 시스템콜

-   pid = fork() 가 실행되면 부모 프로세스와 동일한 자식 프로세스가 별도 메모리 공간에 생성
-   자식 프로세스는 pid가 0으로 리턴, 부모 프로세스는 실제 pid 리턴
-   두 프로세스의 변수 및 PC(program count) 값은 동일
-   새로운 프로세스 공간을 별도로 만들고, fork() 시스템콜을 호출한 프로세스(부모 프로세스) 공간을 모두 복사한 후, fork() 시스템콜 이후 코드부터 실행

### execve() 시스템콜 예

-   환경변수를 새로 생성하므로, 기존 사용자가 설정한 환경 변수값은 사용할 수 없다.
-   execl() 시스템콜을 실행시킨 프로세스 공간에 새로운 프로세스 이미지를 덮어씌우고, 새로운 프로세스를 실행
-   perror() 함수가 호출된다는 의미는 새로운 프로세스 이미지로 덮어씌우는 작업이 실행되지 못했다는 의미

-   리눅스 프로세스 실행

    -   부모 프로세스로부터 새로운 프로세스 공간을 만들고 부모 프로세스 데이터 복사(fork)
    -   새로운 프로세스를 위한 바이너리를 새로운 프로세스 공간에 덮어씌움(exec)

-   wait() 시스템콜
    -   wait() 함수를 사용하면, fork() 함수 호출시, 자식 프로세스가 종료할 때까지, 부모 프로세스가 기다림
    -   자식 프로세스와 부모 프로세스의 동기화, 부모 프로세스가 자식 프로세스보다 먼저 죽은 경우를 막기 위해 사용(고아 프로세스)

### fork(), execl(), wait() 시스템콜

-   execl() 만 사용하면, 부모 프로세스가 사라진다
-   이를 유지하기 위해, fork()로 새로운 프로세스 공간 복사 후, execl() 사용
-   wait() 함수를 사용해서 부모 프로세스가 자식 프로세스가 끝날 때까지 기다릴 수 있다
    > 쉘 프로그램은 fork(), exec() 계열, wait() 함수를 기반으로 작성 가능

### atexit() 함수

-   프로세스 종료시 실행될 함수를 등록하기 위해 사용
-   등록된 함수를 등록된 역순서대로 실행

### 우선순위 기반 스케쥴러

-   Priority-Based 스케쥴러

    -   정적 우선순위
        -   프로세스마다 우선순위를 미리 지정
    -   동적 우선순위
        -   스케쥴러가 상황에 따라 우선순위를 동적으로 변경

-   pipe (파이프)
    -   기본 파이프는 단방향 통신
    -   fork()로 자식 프로세스 만들었을 때, 부모와 자식간의 통신
-   메시지 큐
    -   기본 FIFO 정책으로 데이터 전송

### 공유 메모리

-   노골적으로 kernel space에 메모리 공간을 만들고, 해당 공간을 변수처럼 쓰는 방식
-   message queue 처럼 FIFO 방식이 아니라, 해당 메모리 주소를 마치 변수처럼 접근하는 방식
-   공유메모리 key를 가지고, 여러 프로세스가 접근 가능

### 시그널

-   유닉스에서 30년 이상 사용된 전통적인 기법
-   커널 또는 프로세스에서 다른 프로세스에 어떤 이벤트가 발생되었는지를 알려주는 기법

### 시그널 동작

-   프로그램에서 특정 시그널의 기본 동작 대신 다른 동작을 하도록 구현 가능
-   각 프로세스에서 시그널 처리에 대해 다음과 같은 동작 설정 가능
    -   시그널 무시
    -   시그널 블록(블록을 푸는 순간, 해당 프로세스에서 시그널 처리
    -   프로그램 안에 등록된 시그널 핸들러로 재정의한 특정 동작 수행
    -   등록된 시그널 핸들러가 없다면, 커널에서 기본 동작 수행

### 시그널과 프로세스

-   PCB에 해당 프로세스가 블록 또는 처리해야하는 시그널 관련 정보 관리
-   커널 모드에서 사용자 모드 전환시 시그널 정보 확인해서, 해당 처리

### Pthread 란 ?

-   thread 표준 API
    -   POSIX 스레드 또는 Pthread라고 부른다
-   Pthread API
    -   저수준 API로 100여개의 함수 제공
    -   복잡하지만, 유닉스 시스템 핵심 스레딩 라이브러리
    -   다른 스레딩 솔루션도 결국 Pthread를 기반으로 구현되어 있으므로, 익혀둘 가치가 있다.
