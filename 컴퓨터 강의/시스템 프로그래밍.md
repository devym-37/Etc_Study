### 리눅스와 파일

-   모든 것은 파일이라는 철학을 따른다

    -   모든 인터렉션은 파일을 읽고, 쓰는 것처럼 이루어져있다
    -   마우스, 키보드와 같은 모든 디바이스 관련된 기술도 파일과 같이 다루어진다

-   파일은 inode 고유값과 자료구조에 의해 주요 정보 관리

### 리눅스와 프로세스

-   리눅스 실행 파일 포멧 - ELE
    -   콜스택, 코드(텍스트), 데이터 및 BSS 섹션 등
-   다양한 시스템 리소스와 관련
    -   시스템콜 호출을 통해 리소스 처리 가능토록 구성
        -   타이머, 시그널, 파일, 네트워크, 디바이스, IPC기법
-   가상 메모리 지원
-   각 프로세스는 pid(프로세스 ID) 고유값으로 구분
-   init 프로세스(첫 번째 프로세스)를 기반으로 fork() 시스템콜을 사용해서, 신규 프로세스가 생성

### 리눅스와 권한

-   운영체제는 사용자/리소스 권한을 관리
-   리눅스는 사용자/그룹으로 권한을 관리
-   root는 슈퍼관리자
-   파일마다 소유자, 소유자 그룹, 모든 사용자에 대해

    -   읽고, 쓰고, 실행하는 권한을 관리
    -   접근 권한 정보는 inode의 자료구조에 저장

-   리눅스는 모든 리소스를 파일로 관리한다. (inode)
-   리눅스의 프로세스
    -   ELF 포맷
    -   시스템콜 기반 리소스 처리 가능토록 구성
        -   타이머, 시그널, 파일, 네트워크 등
    -   가상 메모리 사용
    -   pid 기반 구분
    -   init 프로세스 기반 fork() 사용해서, 프로세스가 생성
-   리눅스 사용자 (로그인 사용자/그룹) 권한 관리
-   리눅스 리소스 (소유자, 소유자 그룹, 모든 사용자에 대한 읽고, 쓰고, 실행하는 권한 설정) 권한 관리

### 리눅스와 파일 정리

-   모든 것은 파일이라는 철학을 따른다
    -   모든 인터렉션은 파일을 읽고, 쓰는 것처럼 이루어져있음
    -   마우스, 키보드와 같은 모든 디바이스 관련된 기술도 파일과 같이 다루어진다
    -   모든 자원에 대한 추상화 인터페이스로 파일 인터페이스를 활용

### 슈퍼블록, inode와 파일

-   슈퍼블록 : 파일 시스템의 정보
-   파일 : inode 고유값과 자료구조에 의해 주요 정보 관리
    -   ‘파일이름 : inode’로 파일이름은 inode 번호와 매칭
    -   파일 시스템에서는 inode를 기반으로 파일 엑세스
    -   inode 기반 메타 데이터 저장

### 하드 링크와 소프트 링크

-   하드 링크 / 소프트 링크 둘다 어느 하나 파일을 수정하면, 각 파일 이름으로 동일한 내용 접근 가능

### 특수 파일

-   디바이스

    -   블록 디바이스 : HDD, CD/DVD와 같이 블록 또는 섹터 등 정해진 단위로 데이터 전송, IO 송수신 속도가 높음
    -   캐릭터 디바이스 : 키보드, 마우스 등 byte 단위 데이터 전송, IO 송수신 속도가 낮음

-   파일 추상화 인터페이스를 활용 다양한 데이터/디바이스 접근
-   파일 네임스페이스는 전역 네임스페이스 활용(/media/floofy/dava.jpg)
-   ‘파일 이름 : inode’로 매칭, 파일 시스템은 inode 기반 접근
-   하드 링크 : 동일 inode 가리키는 파일 이름만 하나 더 만든다
-   소프트 링크 : 특정 파일 바로가기 파일을 만든다
-   ln 명령 알아두기
-   특수 파일 : 블록 / 캐릭터 디바이스

### 시스템 프로그래밍의 기반 요소

-   시스템 콜
-   C 라이브러리
-   C 컴파일러
    > 사용자 영역에서의 시스템 프로그래밍

### 시스템 콜

-   시스템콜 : 운영체제 리소스나 서비스 요청을 위해, 사용자 영역에서 커널 영역으로 들어가는 함수
-   주요 시스템콜 : read(), write(), open() 등
    > 리눅스/유닉스는 C언어로 만들어져있으므로, 시스템콜도 C언어로 구현

### 시스템 콜은 어떻게 구현하나?

-   eat 레지스터에 시스템 콜 번호를 넣고, ebx레지스터에는 시스템 콜에 해당하는 인자값을 넣고, 소프트웨어 인터럽트 명령을 호출하면서 0x80값을 넘겨준다

    -   CPU는 사용자 모드를 커널 모드로 바꿔준다
    -   IDT(Interrupt Descriptor Table)에서 0x80에서 해당하는 주소(함수)를 찾아서 실행한다
    -   system_call() 함수에서 eax로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동
    -   해당 시스템콜 함수 실행 후, 다시 커널 모드에서 사용자 모드로 변경하고, 다시 해당 프로세스 다음 코드 진행

### API

-   응용 프로그램과 분리된 하위 호환 인터페이스
    -   예 : 시스템 콜 래퍼, 입출력 라이브러리 등
